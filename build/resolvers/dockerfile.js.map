{"version":3,"sources":["../src/resolvers/dockerfile.ts"],"names":[],"mappings":";;AAAA,oCAAmC;AAInC;IAAA;QACQ,aAAQ,GAAG,CAAC,CAAA;QACZ,SAAI,GAAG,qBAAqB,CAAA;QAE3B,kBAAa,GAAY,KAAK,CAAA;IAyBvC,CAAC;IAnBO,KAAK,CAAC,IAAc;QAC1B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,CAAC;YAChC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAA;YACzB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAA;QACnD,CAAC;IACF,CAAC;IAEM,WAAW;QACjB,MAAM,CAAC,IAAI,CAAC,aAAa,CAAA;IAC1B,CAAC;IAEM,OAAO;QACb,iEAAiE;QACjE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;IAC3B,CAAC;IAEM,qBAAqB;QAC3B,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAA;IAC/B,CAAC;CACD;AA7BD,qCA6BC","file":"dockerfile.js","sourcesContent":["import * as Promise from 'bluebird'\n\nimport { Bundle, FileInfo, Resolver } from '../resolver'\n\nexport default class DockerfileResolver implements Resolver {\n\tpublic priority = 0\n\tpublic name = 'Standard Dockerfile'\n\n\tprivate gotDockerfile: boolean = false\n\t// Storing the contents of the Dockerfile allows us to\n\t// call the hook on it, without traversing the new tar\n\t// stream\n\tprivate dockerfileContents: string\n\n\tpublic entry(file: FileInfo): void {\n\t\tif (file.name === 'Dockerfile') {\n\t\t\tthis.gotDockerfile = true\n\t\t\tthis.dockerfileContents = file.contents.toString()\n\t\t}\n\t}\n\n\tpublic isSatisfied(): boolean {\n\t\treturn this.gotDockerfile\n\t}\n\n\tpublic resolve(): Promise<FileInfo[]> {\n\t\t// We don't need to add any extra files to the Dockerfile project\n\t\treturn Promise.resolve([])\n\t}\n\n\tpublic getDockerfileContents(): string {\n\t\treturn this.dockerfileContents\n\t}\n}\n"],"sourceRoot":"../src"}